// n이라는 값을 소인수 분해했을 때
// n = 2^e * M(홀수) 이다
// 원소가 2인 것만 집어넣은 배열을 E라고 하고 크기를 e라고 하자
// M을 이루는 소수의 개수 -> 2인걸 제외하고 홀수인 것만 넣은 배열을 O라고하고 크기를 o라고 하자

// 홀수인 약수의 개수는 oC0 + oC1 + oC2 + ... + oCo = 2^o개 이다
// 이때, 소인수분해 배열은 2이상의 소수만 들어가기때문에 1인 약수를 넣기위해 oC0을 더한 것

// 짝수의 약수 개수는 (전체 약수 개수 - 홀수 약수 개수) 이다
// 전체 약수 개수는 공식에 의해서 (소인수분해했을 때 2의 개수 + 1) * 홀수 약수의 개수
// 이는 (e+1) * 2^o 이다
// 따라서 짝수의 약수 개수는 (e+1) * 2^o - 2^o 이므로 e * 2^o 개이다

// 이에 따라 K-특별한 수 조건은 e * 2^o = K * 2^o 이므로 e = K인 조건이다
// 따라서 소인수분해를 했을 때, 2의 개수가 K개면 된다! => e = K

#include <iostream>
#include <cmath>

using namespace std;

typedef long long ll;

ll N, K;

ll cnt_special_k() {
	// 1 << 1 은 1의 비트를 왼쪽으로 1칸이므로 2^1
	// 1 << 2 는 왼쪽 두칸이므로 2^2
	// 이 비트연산을 이용해서 2^K 값을 구하고
	// 2^K > N 이면
	// N이하의 수에서 e = K 인 경우를 구해야하는데, 2^e = 2^K 인 수가 존재할 수 없으므로 0 반환

	// 단! 위와 같이 하면 오버플로우 발생! 2^(10^18)이 될 수 있기 때문
	// long long 타입은 64비트로 2^63 - 1 값까지 표현 가능하다
	// 2^63 - 1 은 약 9.22 x 10^18 이므로
	// K가 60이면 2^60이고 해당 값은 10^18보다 큼
	// 따라서 K >= 60 인 경우는 2^k > N 을 항상 만족 시킨다
	if (K >= 60) return 0;

	// N이하인 x가 K-특별한 수가 되려면
	// x = 2^e * M(홀수) 를 만족해야 하고 e = k가 되어야 함
	// 그러면 x는 2^k의 배수가 될 수 밖에 없음
	// 따라서 N / 2^k를 하면 2^k로 N이하의 수를 만들 수 있는 경우의 수가 나옴
	// 단 무조건 2^k의 배수여야하고 2^(k+1)의 배수면 안됨 -> 따라서 2^(k+1)의 배수를 빼줌

	// 2^k 배수 집합 = { 2^K, 2×2^K, 3×2^K, 4×2^K, 5×2^K, 6×2^K, ... }
	// 2^(k+1) 배수 집합 = { 2^(K+1), 2×2^(K+1), 3×2^(K+1), ... }
	// 따라서 (2^k 배수 집합 - 2^(k+1) 배수 집합)을 하면 2^k의 배수만 남음(M이 홀수만 남는 것)
	return (N / (1ll << K)) - (N / (1ll << (K + 1)));
}

int main() {
	ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);

	// 테스트 케이스
	int T;
	cin >> T;
	for (int i = 0; i < T; i++) {
		cin >> N >> K;
		cout << cnt_special_k() << "\n";
	}

	return 0;
}